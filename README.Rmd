---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# htcrosstabs

<!-- badges: start -->
<!-- badges: end -->

The goal of htcrosstabs is to easily create printable crosstabs from raw data frames.

## Installation

You can install the development version of htcrosstabs like so:

``` r
devtools::install_github("HealthTree-Research-Team/htcrosstabs")
```

And you can load it like so:

``` r
library(htcrosstabs)
```

```{r, include = FALSE}
library(htcrosstabs)
```

# Quick Start

The fast way to create crosstabs is to pass your data frame into `crosstab_stacked()`, telling it if you have a cohort column. Then pass the object into `kbl()`; not the `kableExtra` one, the one that comes with `htcrosstabs`. It works exactly the same way, but applies some automatic formatting like adding auto-generated footnotes and row groupings.

``` r
new_crosstab <- crosstab_stacked(
    iris,
    cohort_col_name = "Species"
)

kbl(new_crosstab)
```

# More Detailed

## Example Data

If you'd like to run the code you see here, here is some example data:


## Creating a Crosstab

A simple crosstab can be created from a one-column data frame.

```{r}
sports <- sports_by_age[, "sport", drop = FALSE]
head(sports, 5)

new_crosstab <- crosstab(sports)
```

A crosstab can group data into cohorts by providing a two column data frame, one for the data and one for the cohorts. Simply provide the name of the cohort column when creating it.

```{r}
head(sports_by_age, 5)

new_crosstab <- crosstab(sports_by_age, cohort_col_name = "age")
```

## Crosstab Types

Crosstabs can hold multiple data types: categorical, numeric, Likert-like, and multi-response. The data type is automatically determined when you create the crosstab.

Categorical crosstabs are the default data type. Character values, logical values, and factors will all be counted as categorical.

```{r}
head(sports_by_age, 5) # Categorical

new_crosstab <- crosstab(sports_by_age, "age")
```

Numeric crosstabs are the default when the data is numbers.

```{r}
head(length_by_species, 5)

new_crosstab <- crosstab(length_by_species, "species")
```

Likert crosstabs are created when categorical data is provided, along with a named vector to map values to numbers.

```{r}
head(licorice_by_region, 5)

opinion_map <- c("likes" = 1, "neither" = 0, "dislikes" = -1)

new_crosstab <- crosstab(licorice_by_region, "region", var_map = opinion_map)
```

Multi-response crosstabs are created by providing a list-column allowing multiple answers per row.

```{r}
head(allergies_by_school, 5)

new_crosstab <- crosstab(allergies_by_school, "school")
```

## Checking and Casting Data Types

You can check the data type and whether it's grouped or not with `is.crosstab.*()` functions.

```{r}
new_crosstab <- crosstab(length_by_species, "species")

is.crosstab.grouped(new_crosstab)
is.crosstab.categorical(new_crosstab)
is.crosstab.numeric(new_crosstab)
is.crosstab.likert(new_crosstab)
is.crosstab.multi(new_crosstab)
```

You can also, if needed, cast one data type to another using the `as.crosstab.*()` functions. The details on how the conversion is done can be found in the man pages by typing `?cast_crosstab`.

```{r}
new_crosstab <- crosstab(licorice_by_region, "region", opinion_map)
is.crosstab.likert(new_crosstab)

new_crosstab <- as.crosstab.num(new_crosstab)
is.crosstab.likert(new_crosstab)
```

## Analysis

You can see the data from the crosstabs by using `data_table()`. Ungrouped data has a dummy cohort column with the name of the final output column.

```{r}
new_crosstab <- crosstab(sports)
data_table(new_crosstab) |> head(5)
```

You can extract useful values with the `get_*()` functions. You can get values like the mean, standard deviation, median, iqr, percentages, counts, etc. A full list is available in the man pages with `?get_values`.

```{r}
new_crosstab <- crosstab(length_by_species, "species")

get_mean(new_crosstab)

get_complete_total(new_crosstab)
```

There is also a function `join_val()` which lets you quickly and automatically join different variable tables.

```{r}
new_crosstab <- crosstab(length_by_species, "species")

join_val(
    get_complete(new_crosstab),
    get_mean(new_crosstab),
    get_sd(new_crosstab)
)

new_crosstab <- crosstab(sports_by_age, "age")

join_val(
    get_complete(new_crosstab),
    get_count(new_crosstab),
    get_proportion(new_crosstab)
)
```

You can also do statistical analysis quickly, like an ANOVA, chi-square, or Rao-Scott corrected chi-square test with `get_*_p_value()` functions. Post hocs return a symmetric data frame/matrix of pairwise p-values, which are by default corrected using the Benjamini-Hochberg correction. You can change the correction method with `method = ...`, or you can disable correction completely with `p.adj = FALSE`.

```{r}
new_crosstab <- crosstab(length_by_species, "species")

get_anova_p_value(new_crosstab)

get_tukey_posthoc(new_crosstab)
```

## Adding Formatted Rows

You can add rows with pre-formatted data by using the `add_*_row()` functions. A full list of functions can be found in the man pages with `?add_formatted_rows`. You can also extract the rows separate from the crosstab object with the `get_*_row()` functions.

The order of the rows and columns is determined by the factor levels of the input data frame.

```{r}
crosstab(length_by_species, "species") |> 
    add_complete_total_row() |> 
    add_mean_sd_row() |> 
    add_med_q1_q3_row()

crosstab(sports_by_age, "age") |> 
    add_complete_total_row() |> 
    add_count_rows()
```

## Adding Pre-Built Tables

Certain types of data have common types of rows you usually want, so we have preset templates you can call if you want.

```{r}
satisfaction_map <- c("very satisfied" = 3, "somewhat satisfied" = 2, "not satisfied" = 1)
crosstab(satisfaction_by_company, "company", satisfaction_map) |> 
    add_likert_table()

crosstab(allergies_by_school, "school") |> 
    add_categorical_table()
```

You can also choose `add_default_table()` and it will decide automatically based on the data you passed in.

```{r}
crosstab(length_by_species, "species") |> 
    add_default_table()

crosstab(sports_by_age, "age") |> 
    add_default_table()
```

## Stacking Crosstabs

If you want stacked crosstabs, there are two ways to do it:

The first way is to make two crosstabs and manually stack them with `stack_crosstabs()`. You can stack as many as you want.

```{r}
ct1 <- iris[, c("Sepal.Length", "Species")] |> 
    crosstab("Species") |> 
    add_default_table(anova = F)

ct2 <- iris[, c("Petal.Length", "Species")] |> 
    crosstab("Species") |> 
    add_default_table(anova = F)

ct3 <- iris[, c("Sepal.Width", "Species")] |> 
    crosstab("Species") |> 
    add_default_table(anova = F)

ct4 <- iris[, c("Petal.Width", "Species")] |> 
    crosstab("Species") |> 
    add_default_table(anova = F)

stack_crosstabs(ct1, ct2, ct3, ct4)
```

The second is to call `crosstab_stacked()` which runs through a data frame and automatically applies the default table format.

```{r}
crosstab_stacked(iris, "Species", anova = F)

crosstab_stacked(students, "university", anova = F, chisq = F)
```

## Printable Output

The `kableExtra` package contains a lot of good stuff, so I made a wrapper for the `kbl()` function which will recognize a crosstab object and automatically apply formatting such as auto-generated footnotes.

``` r
new_crosstab <- crosstab_stacked(students, "university")

htcrosstabs::kbl(new_crosstab)
```

# Other Utilities

Because the output order of the rows and columns is determined by factor levels, and because multi-response data is handled in list-columns, and because list-columns are a pain to factorize, I included wrappers for `factor()` and `levels()` which include support for list-columns.

```{r}
head(allergies_by_school, 5)

new_allergies <- factor(allergies_by_school$allergies, levels = c("nuts", "eggs", "milk", "gluten"))
levels(new_allergies)
```

I also included a function `default_var_map()` which will automatically generate a likert map based on factor levels.

```{r}
default_var_map(students$prof_support)
```


