% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/factor_extensions.R
\name{factor_extensions}
\alias{factor_extensions}
\alias{factor}
\alias{levels}
\alias{levels<-}
\alias{is.factorlist}
\title{Detect Lists of Factors}
\usage{
factor(
  obj,
  levels = NULL,
  end_levels = NULL,
  drop_levels = FALSE,
  order_method = "freq",
  ...
)

levels(obj)

levels(obj) <- value

is.factorlist(obj)
}
\arguments{
\item{obj}{The vector or list you wish to factorize}

\item{levels}{Character vector - The levels to be placed at the front of the factor levels}

\item{end_levels}{Character vector - The levels to be placed at the end of the factor levels}

\item{drop_levels}{Logical - Whether levels not in `levels` or `end_levels` should be dropped}

\item{order_method}{Character - "freq" will order unspecified levels by frequency, "seq" will order unspecified values by the order in which they appear.}

\item{...}{All other parameters to be passed to [base::factor()]}

\item{value}{The new levels vector to be applied to obj in `levels()` setter}
}
\value{
`factor()` returns the object with factor levels applied, `levels()` returns the levels applied, and `is.factorlist()` returns a logical for whether it's a list of factors
}
\description{
Drop-in replacement for [base::factor()] with added support for lists of
factors.
}
\details{
This wrapper is a drop-in replacement for [base::factor()]. Because row and
column ordering is determined by factor levels, and multi-response data is
passed in as a list-column, these wrappers for [base::factor()] and
[base::levels()] add functionality to recursively apply to each item in a
list. This ensures that all values in a list have the same factor levels
without any [lapply()] nonsense.

There is added functionality for the `levels` parameter of `factor()`.
Usually `levels` requires all values of factor() to be accounted for, but
this function will keep all levels and place the values in `levels` at the
front. Values you want at the end go in `end_levels`. Now, that said, if you
do want unaccounted levels to drop like the base functionality, set
`drop_levels = TRUE`.
}
\section{Functions}{
\itemize{
\item \code{factor()}: Wrapper for [base::factor()] with support for lists

\item \code{levels()}: Wrapper for [base::levels()] with support for lists

\item \code{levels(obj) <- value}: Wrapper for [base::`levels<-`()] with support for lists

\item \code{is.factorlist()}: Returns whether `obj` is a list of factors

}}
\examples{
sports_levels <- c("Soccer", "Football", "Basketball")
sports <- list(
    person_1 = c("Basketball", "Soccer"),
    person_2 = c("Soccer"),
    person_3 = c("Football", "Soccer")
)

sports # Regular list of character vectors

sports_factors <- htcrosstabs::factor(sports, end_levels = "Soccer")
sports_factors # Each item's levels contains all values

htcrosstabs::levels(sports_factors) <- sports_levels # Sets levels
htcrosstabs::levels(sports_factors) # Extracts levels from the entire list

is.factorlist(sports_factors)

}
