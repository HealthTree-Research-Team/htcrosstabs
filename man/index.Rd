% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crosstab.R
\name{index}
\alias{index}
\alias{index<-}
\title{Create an Index of Row Sections}
\usage{
index(ct, long = FALSE)

index(ct) <- value
}
\arguments{
\item{ct}{The crosstab you want to create the index for}

\item{long}{Logical, setting `TRUE` converts the condensed numeric intex to a character index with as many values as `ct` has rows.}

\item{value}{The replacement index vector}
}
\value{
A vector describing the sections or groups of rows, especially useful for kableExtra::pack_rows()
}
\description{
As you add more rows and even other tables to the table, `index()` keeps
track of which rows belong to which section. This is useful for functions
like [kableExtra::pack_rows()] which requires a named numeric vector.
}
\details{
If we had a crosstab for ages, by the time we are done the index might groups
the rows into sections like `c(Age = 2, ANOVA = 1)`, meaning the first 2 rows
will be under the heading Age and the next 1 is under the heading ANOVA.

Setting `long = TRUE` will convert the index to a character vector with one
value for each row, like `c("Age", "Age", "ANOVA")`.

The setter `index(ct) <- new_index` sets a custom index and can be passed
input in either condensed (named numeric vector) or long (character vector)
form. The condensed form must have the same sum as there are rows in ct, and
the long form must have the same length as there are rows in ct.
}
\examples{
num_ct <- crosstab(length_by_species, cohort_col_name = "species") |>
    add_complete_total_row() |>
    add_mean_sd_row() |>
    add_med_q1_q3_row() |>
    add_anova_rows()

num_ct # The output table
index(num_ct) # The condensed row groupings
index(num_ct, long = TRUE) # The long row groupings

index(num_ct) <- c("sec1" = 2, "sec2" = 2, "sec3" = 2)
index(num_ct)

}
